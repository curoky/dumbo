/**
 * Autogenerated by Thrift for
 * /home/curoky/repos/cpp/dumbo/dumbo/scaffold/serialization/fbthrift/mock.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "dumbo/scaffold/serialization/fbthrift/gen-cpp2/mock_types.h"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "dumbo/scaffold/serialization/fbthrift/gen-cpp2/mock_data.h"
#include "dumbo/scaffold/serialization/fbthrift/gen-cpp2/mock_types.tcc"

namespace apache {
namespace thrift {

constexpr std::size_t const TEnumTraits<::idl::thrift::cpp2::EnumType>::size;
folly::Range<::idl::thrift::cpp2::EnumType const*> const
    TEnumTraits<::idl::thrift::cpp2::EnumType>::values =
        folly::range(TEnumDataStorage<::idl::thrift::cpp2::EnumType>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::idl::thrift::cpp2::EnumType>::names =
    folly::range(TEnumDataStorage<::idl::thrift::cpp2::EnumType>::names);

char const* TEnumTraits<::idl::thrift::cpp2::EnumType>::findName(type value) {
  using factory = ::idl::thrift::cpp2::_EnumType_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::idl::thrift::cpp2::EnumType>::findValue(char const* name, type* out) {
  using factory = ::idl::thrift::cpp2::_EnumType_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}  // namespace thrift
}  // namespace apache

namespace idl {
namespace thrift {
namespace cpp2 {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _EnumType_EnumMapFactory::ValuesToNamesMapType _EnumType_VALUES_TO_NAMES =
    _EnumType_EnumMapFactory::makeValuesToNamesMap();
const _EnumType_EnumMapFactory::NamesToValuesMapType _EnumType_NAMES_TO_VALUES =
    _EnumType_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}  // namespace cpp2
}  // namespace thrift
}  // namespace idl

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::idl::thrift::cpp2::UnionType>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
      "var_i16",
      "var_i32",
  };
  static constexpr int16_t _ids[] = {
      1,
      2,
  };
  static constexpr TType _types[] = {
      TType::T_I16,
      TType::T_I32,
  };
  static constexpr st::translate_field_name_table table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

}  // namespace detail
}  // namespace thrift
}  // namespace apache

namespace apache {
namespace thrift {

constexpr std::size_t const TEnumTraits<::idl::thrift::cpp2::UnionType::Type>::size;
folly::Range<::idl::thrift::cpp2::UnionType::Type const*> const
    TEnumTraits<::idl::thrift::cpp2::UnionType::Type>::values =
        folly::range(TEnumDataStorage<::idl::thrift::cpp2::UnionType::Type>::values);
folly::Range<folly::StringPiece const*> const
    TEnumTraits<::idl::thrift::cpp2::UnionType::Type>::names =
        folly::range(TEnumDataStorage<::idl::thrift::cpp2::UnionType::Type>::names);

char const* TEnumTraits<::idl::thrift::cpp2::UnionType::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::idl::thrift::cpp2::UnionType::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::idl::thrift::cpp2::UnionType::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::idl::thrift::cpp2::UnionType::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}  // namespace thrift
}  // namespace apache
namespace idl {
namespace thrift {
namespace cpp2 {

void UnionType::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) {
    return;
  }
  switch (type_) {
    case Type::var_i16:
      destruct(value_.var_i16);
      break;
    case Type::var_i32:
      destruct(value_.var_i32);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool UnionType::operator==(const UnionType& rhs) const {
  if (type_ != rhs.type_) {
    return false;
  }
  switch (type_) {
    case Type::var_i16:
      return value_.var_i16 == rhs.value_.var_i16;
    case Type::var_i32:
      return value_.var_i32 == rhs.value_.var_i32;
    default:
      return true;
  }
}

bool UnionType::operator<(const UnionType& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::var_i16:
      return lhs.value_.var_i16 < rhs.value_.var_i16;
    case Type::var_i32:
      return lhs.value_.var_i32 < rhs.value_.var_i32;
    default:
      return false;
  }
}

void swap(UnionType& a, UnionType& b) {
  UnionType temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void UnionType::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t UnionType::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t UnionType::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t UnionType::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void UnionType::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t UnionType::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t UnionType::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t UnionType::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

}  // namespace cpp2
}  // namespace thrift
}  // namespace idl
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::idl::thrift::cpp2::MockRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 18;
  static constexpr folly::StringPiece _names[] = {
      "var_bool",
      "var_byte",
      "var_i16",
      "var_i32",
      "var_i64",
      "var_double",
      "var_string",
      "var_binary",
      "var_string_type",
      "var_string_list",
      "var_binary_list",
      "var_string_set",
      "var_string_binary_map",
      "var_enum",
      "var_enum_set",
      "var_union",
      "var_required_i32",
      "var_optional_i32",
  };
  static constexpr int16_t _ids[] = {
      1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
  };
  static constexpr TType _types[] = {
      TType::T_BOOL,   TType::T_BYTE,   TType::T_I16,    TType::T_I32,    TType::T_I64,
      TType::T_DOUBLE, TType::T_STRING, TType::T_STRING, TType::T_STRING, TType::T_LIST,
      TType::T_LIST,   TType::T_SET,    TType::T_MAP,    TType::T_I32,    TType::T_SET,
      TType::T_STRUCT, TType::T_I32,    TType::T_I32,
  };
  static constexpr st::translate_field_name_table table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

}  // namespace detail
}  // namespace thrift
}  // namespace apache

namespace idl {
namespace thrift {
namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MockRequest::MockRequest()
    : var_bool(0),
      var_byte(0),
      var_i16(0),
      var_i32(0),
      var_i64(0),
      var_double(0),
      var_enum(::idl::thrift::cpp2::EnumType::ZERO),
      var_required_i32(0),
      var_optional_i32(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END

MockRequest::~MockRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MockRequest::MockRequest(apache::thrift::FragileConstructor, bool var_bool__arg,
                         int8_t var_byte__arg, int16_t var_i16__arg, int32_t var_i32__arg,
                         int64_t var_i64__arg, double var_double__arg,
                         ::std::string var_string__arg, ::std::string var_binary__arg,
                         ::idl::thrift::cpp2::StrType var_string_type__arg,
                         ::std::vector<::std::string> var_string_list__arg,
                         ::std::vector<::std::string> var_binary_list__arg,
                         ::std::set<::std::string> var_string_set__arg,
                         ::std::map<::std::string, ::std::string> var_string_binary_map__arg,
                         ::idl::thrift::cpp2::EnumType var_enum__arg,
                         ::std::set<::idl::thrift::cpp2::EnumType> var_enum_set__arg,
                         ::idl::thrift::cpp2::UnionType var_union__arg,
                         int32_t var_required_i32__arg, int32_t var_optional_i32__arg)
    : var_bool(std::move(var_bool__arg)),
      var_byte(std::move(var_byte__arg)),
      var_i16(std::move(var_i16__arg)),
      var_i32(std::move(var_i32__arg)),
      var_i64(std::move(var_i64__arg)),
      var_double(std::move(var_double__arg)),
      var_string(std::move(var_string__arg)),
      var_binary(std::move(var_binary__arg)),
      var_string_type(std::move(var_string_type__arg)),
      var_string_list(std::move(var_string_list__arg)),
      var_binary_list(std::move(var_binary_list__arg)),
      var_string_set(std::move(var_string_set__arg)),
      var_string_binary_map(std::move(var_string_binary_map__arg)),
      var_enum(std::move(var_enum__arg)),
      var_enum_set(std::move(var_enum_set__arg)),
      var_union(std::move(var_union__arg)),
      var_required_i32(std::move(var_required_i32__arg)),
      var_optional_i32(std::move(var_optional_i32__arg)) {
  __isset.var_bool = true;
  __isset.var_byte = true;
  __isset.var_i16 = true;
  __isset.var_i32 = true;
  __isset.var_i64 = true;
  __isset.var_double = true;
  __isset.var_string = true;
  __isset.var_binary = true;
  __isset.var_string_type = true;
  __isset.var_string_list = true;
  __isset.var_binary_list = true;
  __isset.var_string_set = true;
  __isset.var_string_binary_map = true;
  __isset.var_enum = true;
  __isset.var_enum_set = true;
  __isset.var_union = true;
  __isset.var_optional_i32 = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MockRequest::__clear() {
  // clear all fields
  var_bool = 0;
  var_byte = 0;
  var_i16 = 0;
  var_i32 = 0;
  var_i64 = 0;
  var_double = 0;
  var_string = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  var_binary = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  var_string_type = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  var_string_list.clear();
  var_binary_list.clear();
  var_string_set.clear();
  var_string_binary_map.clear();
  var_enum = ::idl::thrift::cpp2::EnumType::ZERO;
  var_enum_set.clear();
  ::apache::thrift::Cpp2Ops<::idl::thrift::cpp2::UnionType>::clear(&var_union);
  var_required_i32 = 0;
  var_optional_i32 = 0;
  THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
  THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MockRequest::operator==(const MockRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.var_bool == rhs.var_bool)) {
    return false;
  }
  if (!(lhs.var_byte == rhs.var_byte)) {
    return false;
  }
  if (!(lhs.var_i16 == rhs.var_i16)) {
    return false;
  }
  if (!(lhs.var_i32 == rhs.var_i32)) {
    return false;
  }
  if (!(lhs.var_i64 == rhs.var_i64)) {
    return false;
  }
  if (!(lhs.var_double == rhs.var_double)) {
    return false;
  }
  if (!(lhs.var_string == rhs.var_string)) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.var_binary, rhs.var_binary)) {
    return false;
  }
  if (!(lhs.var_string_type == rhs.var_string_type)) {
    return false;
  }
  if (!(lhs.var_string_list == rhs.var_string_list)) {
    return false;
  }
  if (!(lhs.var_binary_list == rhs.var_binary_list)) {
    return false;
  }
  if (!(lhs.var_string_set == rhs.var_string_set)) {
    return false;
  }
  if (!(lhs.var_string_binary_map == rhs.var_string_binary_map)) {
    return false;
  }
  if (!(lhs.var_enum == rhs.var_enum)) {
    return false;
  }
  if (!(lhs.var_enum_set == rhs.var_enum_set)) {
    return false;
  }
  if (!(lhs.var_union == rhs.var_union)) {
    return false;
  }
  if (!(lhs.var_required_i32 == rhs.var_required_i32)) {
    return false;
  }
  if (lhs.var_optional_i32_ref() != rhs.var_optional_i32_ref()) {
    return false;
  }
  return true;
}

bool MockRequest::operator<(const MockRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.var_bool == rhs.var_bool)) {
    return lhs.var_bool < rhs.var_bool;
  }
  if (!(lhs.var_byte == rhs.var_byte)) {
    return lhs.var_byte < rhs.var_byte;
  }
  if (!(lhs.var_i16 == rhs.var_i16)) {
    return lhs.var_i16 < rhs.var_i16;
  }
  if (!(lhs.var_i32 == rhs.var_i32)) {
    return lhs.var_i32 < rhs.var_i32;
  }
  if (!(lhs.var_i64 == rhs.var_i64)) {
    return lhs.var_i64 < rhs.var_i64;
  }
  if (!(lhs.var_double == rhs.var_double)) {
    return lhs.var_double < rhs.var_double;
  }
  if (!(lhs.var_string == rhs.var_string)) {
    return lhs.var_string < rhs.var_string;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.var_binary, rhs.var_binary)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.var_binary, rhs.var_binary);
  }
  if (!(lhs.var_string_type == rhs.var_string_type)) {
    return lhs.var_string_type < rhs.var_string_type;
  }
  if (!(lhs.var_string_list == rhs.var_string_list)) {
    return lhs.var_string_list < rhs.var_string_list;
  }
  if (!(lhs.var_binary_list == rhs.var_binary_list)) {
    return lhs.var_binary_list < rhs.var_binary_list;
  }
  if (!(lhs.var_string_set == rhs.var_string_set)) {
    return lhs.var_string_set < rhs.var_string_set;
  }
  if (!(lhs.var_string_binary_map == rhs.var_string_binary_map)) {
    return lhs.var_string_binary_map < rhs.var_string_binary_map;
  }
  if (!(lhs.var_enum == rhs.var_enum)) {
    return lhs.var_enum < rhs.var_enum;
  }
  if (!(lhs.var_enum_set == rhs.var_enum_set)) {
    return lhs.var_enum_set < rhs.var_enum_set;
  }
  if (!(lhs.var_union == rhs.var_union)) {
    return lhs.var_union < rhs.var_union;
  }
  if (!(lhs.var_required_i32 == rhs.var_required_i32)) {
    return lhs.var_required_i32 < rhs.var_required_i32;
  }
  if (lhs.var_optional_i32_ref() != rhs.var_optional_i32_ref()) {
    return lhs.var_optional_i32_ref() < rhs.var_optional_i32_ref();
  }
  return false;
}

const ::std::vector<::std::string>& MockRequest::get_var_string_list() const& {
  return var_string_list;
}

::std::vector<::std::string> MockRequest::get_var_string_list() && {
  return std::move(var_string_list);
}

const ::std::vector<::std::string>& MockRequest::get_var_binary_list() const& {
  return var_binary_list;
}

::std::vector<::std::string> MockRequest::get_var_binary_list() && {
  return std::move(var_binary_list);
}

const ::std::set<::std::string>& MockRequest::get_var_string_set() const& { return var_string_set; }

::std::set<::std::string> MockRequest::get_var_string_set() && { return std::move(var_string_set); }

const ::std::map<::std::string, ::std::string>& MockRequest::get_var_string_binary_map() const& {
  return var_string_binary_map;
}

::std::map<::std::string, ::std::string> MockRequest::get_var_string_binary_map() && {
  return std::move(var_string_binary_map);
}

const ::std::set<::idl::thrift::cpp2::EnumType>& MockRequest::get_var_enum_set() const& {
  return var_enum_set;
}

::std::set<::idl::thrift::cpp2::EnumType> MockRequest::get_var_enum_set() && {
  return std::move(var_enum_set);
}

const ::idl::thrift::cpp2::UnionType& MockRequest::get_var_union() const& { return var_union; }

::idl::thrift::cpp2::UnionType MockRequest::get_var_union() && { return std::move(var_union); }

void swap(MockRequest& a, MockRequest& b) {
  using ::std::swap;
  swap(a.var_bool_ref().value(), b.var_bool_ref().value());
  swap(a.var_byte_ref().value(), b.var_byte_ref().value());
  swap(a.var_i16_ref().value(), b.var_i16_ref().value());
  swap(a.var_i32_ref().value(), b.var_i32_ref().value());
  swap(a.var_i64_ref().value(), b.var_i64_ref().value());
  swap(a.var_double_ref().value(), b.var_double_ref().value());
  swap(a.var_string_ref().value(), b.var_string_ref().value());
  swap(a.var_binary_ref().value(), b.var_binary_ref().value());
  swap(a.var_string_type_ref().value(), b.var_string_type_ref().value());
  swap(a.var_string_list_ref().value(), b.var_string_list_ref().value());
  swap(a.var_binary_list_ref().value(), b.var_binary_list_ref().value());
  swap(a.var_string_set_ref().value(), b.var_string_set_ref().value());
  swap(a.var_string_binary_map_ref().value(), b.var_string_binary_map_ref().value());
  swap(a.var_enum_ref().value(), b.var_enum_ref().value());
  swap(a.var_enum_set_ref().value(), b.var_enum_set_ref().value());
  swap(a.var_union_ref().value(), b.var_union_ref().value());
  swap(a.var_required_i32_ref().value(), b.var_required_i32_ref().value());
  swap(a.var_optional_i32_ref().value_unchecked(), b.var_optional_i32_ref().value_unchecked());
  THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
  THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MockRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MockRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MockRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MockRequest::serializedSizeZC<>(
    apache::thrift::BinaryProtocolWriter const*) const;
template void MockRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MockRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MockRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MockRequest::serializedSizeZC<>(
    apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<MockRequest, ::apache::thrift::type_class::variant,
                                                 ::idl::thrift::cpp2::UnionType>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MockRequest, ::apache::thrift::type_class::variant, ::idl::thrift::cpp2::UnionType>,
    "inconsistent use of nimble option");

}  // namespace cpp2
}  // namespace thrift
}  // namespace idl
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::idl::thrift::cpp2::MockResponse>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
      "req",
  };
  static constexpr int16_t _ids[] = {
      1,
  };
  static constexpr TType _types[] = {
      TType::T_STRUCT,
  };
  static constexpr st::translate_field_name_table table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

}  // namespace detail
}  // namespace thrift
}  // namespace apache

namespace idl {
namespace thrift {
namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MockResponse::MockResponse(apache::thrift::FragileConstructor,
                           ::idl::thrift::cpp2::MockRequest req__arg)
    : req(std::move(req__arg)) {
  __isset.req = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MockResponse::__clear() {
  // clear all fields
  ::apache::thrift::Cpp2Ops<::idl::thrift::cpp2::MockRequest>::clear(&req);
  THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
  THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MockResponse::operator==(const MockResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.req == rhs.req)) {
    return false;
  }
  return true;
}

bool MockResponse::operator<(const MockResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.req == rhs.req)) {
    return lhs.req < rhs.req;
  }
  return false;
}

const ::idl::thrift::cpp2::MockRequest& MockResponse::get_req() const& { return req; }

::idl::thrift::cpp2::MockRequest MockResponse::get_req() && { return std::move(req); }

void swap(MockResponse& a, MockResponse& b) {
  using ::std::swap;
  swap(a.req_ref().value(), b.req_ref().value());
  THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
  THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MockResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MockResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MockResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MockResponse::serializedSizeZC<>(
    apache::thrift::BinaryProtocolWriter const*) const;
template void MockResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MockResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MockResponse::serializedSize<>(
    apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MockResponse::serializedSizeZC<>(
    apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MockResponse, ::apache::thrift::type_class::structure, ::idl::thrift::cpp2::MockRequest>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        MockResponse, ::apache::thrift::type_class::structure, ::idl::thrift::cpp2::MockRequest>,
    "inconsistent use of nimble option");

}  // namespace cpp2
}  // namespace thrift
}  // namespace idl
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::idl::thrift::cpp2::MockException>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname, FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
      "msg",
  };
  static constexpr int16_t _ids[] = {
      1,
  };
  static constexpr TType _types[] = {
      TType::T_STRING,
  };
  static constexpr st::translate_field_name_table table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

}  // namespace detail
}  // namespace thrift
}  // namespace apache

namespace idl {
namespace thrift {
namespace cpp2 {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
MockException::MockException(apache::thrift::FragileConstructor, ::std::string msg__arg)
    : msg(std::move(msg__arg)) {
  __isset.msg = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void MockException::__clear() {
  // clear all fields
  msg = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
  THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool MockException::operator==(const MockException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.msg == rhs.msg)) {
    return false;
  }
  return true;
}

bool MockException::operator<(const MockException& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.msg == rhs.msg)) {
    return lhs.msg < rhs.msg;
  }
  return false;
}

void swap(MockException& a, MockException& b) {
  using ::std::swap;
  swap(a.msg_ref().value(), b.msg_ref().value());
  THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
  THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void MockException::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MockException::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MockException::serializedSize<>(
    apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MockException::serializedSizeZC<>(
    apache::thrift::BinaryProtocolWriter const*) const;
template void MockException::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MockException::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MockException::serializedSize<>(
    apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MockException::serializedSizeZC<>(
    apache::thrift::CompactProtocolWriter const*) const;

}  // namespace cpp2
}  // namespace thrift
}  // namespace idl
