/**
 * Autogenerated by Thrift for
 * /home/curoky/repos/cpp/dumbo/dumbo/scaffold/serialization/fbthrift/mock.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "dumbo/scaffold/serialization/fbthrift/gen-cpp2/EchoServiceAsyncClient.h"

#include <thrift/lib/cpp2/gen/client_cpp.h>

namespace idl {
namespace thrift {
namespace cpp2 {
typedef apache::thrift::ThriftPresult<
    false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,
                                     ::idl::thrift::cpp2::MockRequest*>>
    EchoService_echo_pargs;
typedef apache::thrift::ThriftPresult<
    true,
    apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT,
                              ::idl::thrift::cpp2::MockResponse*>,
    apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,
                              ::idl::thrift::cpp2::MockException>>
    EchoService_echo_presult;
typedef apache::thrift::ThriftPresult<
    false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT,
                                     ::idl::thrift::cpp2::MockRequest*>>
    EchoService_oneway_echo_pargs;

template <typename Protocol_>
void EchoServiceAsyncClient::echoT(
    Protocol_* prot, apache::thrift::RpcOptions& rpcOptions,
    std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx,
    apache::thrift::RequestClientCallback::Ptr callback,
    const ::idl::thrift::cpp2::MockRequest& req) {
  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  EchoService_echo_pargs args;
  args.get<0>().value = const_cast<::idl::thrift::cpp2::MockRequest*>(&req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, Protocol_>(
      prot, rpcOptions, std::move(callback), ctx->ctx, std::move(header), channel_.get(), "echo",
      writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

template <typename Protocol_>
void EchoServiceAsyncClient::oneway_echoT(
    Protocol_* prot, apache::thrift::RpcOptions& rpcOptions,
    std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx,
    apache::thrift::RequestClientCallback::Ptr callback,
    const ::idl::thrift::cpp2::MockRequest& req) {
  std::shared_ptr<apache::thrift::transport::THeader> header(ctx, &ctx->header);
  EchoService_oneway_echo_pargs args;
  args.get<0>().value = const_cast<::idl::thrift::cpp2::MockRequest*>(&req);
  auto sizer = [&](Protocol_* p) { return args.serializedSizeZC(p); };
  auto writer = [&](Protocol_* p) { args.write(p); };
  apache::thrift::clientSendT<apache::thrift::RpcKind::SINGLE_REQUEST_NO_RESPONSE, Protocol_>(
      prot, rpcOptions, std::move(callback), ctx->ctx, std::move(header), channel_.get(),
      "oneway_echo", writer, sizer);
  ctx->reqContext.setRequestHeader(nullptr);
}

void EchoServiceAsyncClient::echo(std::unique_ptr<apache::thrift::RequestCallback> callback,
                                  const ::idl::thrift::cpp2::MockRequest& req) {
  ::apache::thrift::RpcOptions rpcOptions;
  echo(rpcOptions, std::move(callback), req);
}

void EchoServiceAsyncClient::echo(apache::thrift::RpcOptions& rpcOptions,
                                  std::unique_ptr<apache::thrift::RequestCallback> callback,
                                  const ::idl::thrift::cpp2::MockRequest& req) {
  auto ctx = std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId(),
      rpcOptions.releaseWriteHeaders(), this->handlers_, this->getServiceName(),
      "EchoService.echo");
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback =
      apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  echoImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), req);
}

void EchoServiceAsyncClient::echoImpl(
    apache::thrift::RpcOptions& rpcOptions,
    std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx,
    apache::thrift::RequestClientCallback::Ptr callback,
    const ::idl::thrift::cpp2::MockRequest& req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL: {
      apache::thrift::BinaryProtocolWriter writer;
      echoT(&writer, rpcOptions, std::move(ctx), std::move(callback), req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL: {
      apache::thrift::CompactProtocolWriter writer;
      echoT(&writer, rpcOptions, std::move(ctx), std::move(callback), req);
      break;
    }
    default: {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void EchoServiceAsyncClient::sync_echo(::idl::thrift::cpp2::MockResponse& _return,
                                       const ::idl::thrift::cpp2::MockRequest& req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_echo(rpcOptions, _return, req);
}

void EchoServiceAsyncClient::sync_echo(apache::thrift::RpcOptions& rpcOptions,
                                       ::idl::thrift::cpp2::MockResponse& _return,
                                       const ::idl::thrift::cpp2::MockRequest& req) {
  apache::thrift::ClientReceiveState _returnState;
  apache::thrift::ClientSyncCallback<false> callback(&_returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      protocolId, rpcOptions.releaseWriteHeaders(), this->handlers_, this->getServiceName(),
      "EchoService.echo");
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  echoImpl(rpcOptions, ctx, std::move(wrappedCallback), req);
  callback.waitUntilDone(evb);
  _returnState.resetProtocolId(protocolId);
  _returnState.resetCtx(std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx));
  SCOPE_EXIT {
    if (_returnState.header() && !_returnState.header()->getHeaders().empty()) {
      rpcOptions.setReadHeaders(_returnState.header()->releaseHeaders());
    }
  };
  if (!_returnState.buf()) {
    assert(!!_returnState.exception());
    _returnState.exception().throw_exception();
  }
  return folly::fibers::runInMainContext([&] { recv_echo(_return, _returnState); });
}

folly::Future<::idl::thrift::cpp2::MockResponse> EchoServiceAsyncClient::future_echo(
    const ::idl::thrift::cpp2::MockRequest& req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_echo(rpcOptions, req);
}

folly::SemiFuture<::idl::thrift::cpp2::MockResponse> EchoServiceAsyncClient::semifuture_echo(
    const ::idl::thrift::cpp2::MockRequest& req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_echo(rpcOptions, req);
}

folly::Future<::idl::thrift::cpp2::MockResponse> EchoServiceAsyncClient::future_echo(
    apache::thrift::RpcOptions& rpcOptions, const ::idl::thrift::cpp2::MockRequest& req) {
  folly::Promise<::idl::thrift::cpp2::MockResponse> _promise;
  auto _future = _promise.getFuture();
  auto callback =
      std::make_unique<apache::thrift::FutureCallback<::idl::thrift::cpp2::MockResponse>>(
          std::move(_promise), recv_wrapped_echo, channel_);
  echo(rpcOptions, std::move(callback), req);
  return _future;
}

folly::SemiFuture<::idl::thrift::cpp2::MockResponse> EchoServiceAsyncClient::semifuture_echo(
    apache::thrift::RpcOptions& rpcOptions, const ::idl::thrift::cpp2::MockRequest& req) {
  auto callbackAndFuture = makeSemiFutureCallback(recv_wrapped_echo, channel_);
  auto callback = std::move(callbackAndFuture.first);
  echo(rpcOptions, std::move(callback), req);
  return std::move(callbackAndFuture.second);
}

folly::Future<std::pair<::idl::thrift::cpp2::MockResponse,
                        std::unique_ptr<apache::thrift::transport::THeader>>>
EchoServiceAsyncClient::header_future_echo(apache::thrift::RpcOptions& rpcOptions,
                                           const ::idl::thrift::cpp2::MockRequest& req) {
  folly::Promise<std::pair<::idl::thrift::cpp2::MockResponse,
                           std::unique_ptr<apache::thrift::transport::THeader>>>
      _promise;
  auto _future = _promise.getFuture();
  auto callback =
      std::make_unique<apache::thrift::HeaderFutureCallback<::idl::thrift::cpp2::MockResponse>>(
          std::move(_promise), recv_wrapped_echo, channel_);
  echo(rpcOptions, std::move(callback), req);
  return _future;
}

folly::SemiFuture<std::pair<::idl::thrift::cpp2::MockResponse,
                            std::unique_ptr<apache::thrift::transport::THeader>>>
EchoServiceAsyncClient::header_semifuture_echo(apache::thrift::RpcOptions& rpcOptions,
                                               const ::idl::thrift::cpp2::MockRequest& req) {
  auto callbackAndFuture = makeHeaderSemiFutureCallback(recv_wrapped_echo, channel_);
  auto callback = std::move(callbackAndFuture.first);
  echo(rpcOptions, std::move(callback), req);
  return std::move(callbackAndFuture.second);
}

void EchoServiceAsyncClient::echo(
    folly::Function<void(::apache::thrift::ClientReceiveState&&)> callback,
    const ::idl::thrift::cpp2::MockRequest& req) {
  echo(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), req);
}

#if FOLLY_HAS_COROUTINES
#endif  // FOLLY_HAS_COROUTINES
folly::exception_wrapper EchoServiceAsyncClient::recv_wrapped_echo(
    ::idl::thrift::cpp2::MockResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  if (state.isException()) {
    return std::move(state.exception());
  }
  if (!state.buf()) {
    return folly::make_exception_wrapper<apache::thrift::TApplicationException>(
        "recv_ called without result");
  }

  using result = EchoService_echo_presult;
  constexpr auto const fname = "echo";
  switch (state.protocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL: {
      apache::thrift::BinaryProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(fname, &reader, state, _return);
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL: {
      apache::thrift::CompactProtocolReader reader;
      return apache::thrift::detail::ac::recv_wrapped<result>(fname, &reader, state, _return);
    }
    default: {
    }
  }
  return folly::make_exception_wrapper<apache::thrift::TApplicationException>(
      "Could not find Protocol");
}

void EchoServiceAsyncClient::recv_echo(::idl::thrift::cpp2::MockResponse& _return,
                                       ::apache::thrift::ClientReceiveState& state) {
  auto ew = recv_wrapped_echo(_return, state);
  if (ew) {
    ew.throw_exception();
  }
}

void EchoServiceAsyncClient::recv_instance_echo(::idl::thrift::cpp2::MockResponse& _return,
                                                ::apache::thrift::ClientReceiveState& state) {
  return recv_echo(_return, state);
}

folly::exception_wrapper EchoServiceAsyncClient::recv_instance_wrapped_echo(
    ::idl::thrift::cpp2::MockResponse& _return, ::apache::thrift::ClientReceiveState& state) {
  return recv_wrapped_echo(_return, state);
}

void EchoServiceAsyncClient::oneway_echo(std::unique_ptr<apache::thrift::RequestCallback> callback,
                                         const ::idl::thrift::cpp2::MockRequest& req) {
  ::apache::thrift::RpcOptions rpcOptions;
  oneway_echo(rpcOptions, std::move(callback), req);
}

void EchoServiceAsyncClient::oneway_echo(apache::thrift::RpcOptions& rpcOptions,
                                         std::unique_ptr<apache::thrift::RequestCallback> callback,
                                         const ::idl::thrift::cpp2::MockRequest& req) {
  auto ctx = std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId(),
      rpcOptions.releaseWriteHeaders(), this->handlers_, this->getServiceName(),
      "EchoService.oneway_echo");
  apache::thrift::RequestCallback::Context callbackContext;
  callbackContext.oneWay = true;
  callbackContext.protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  callbackContext.ctx = std::shared_ptr<apache::thrift::ContextStack>(ctx, &ctx->ctx);
  auto wrappedCallback =
      apache::thrift::toRequestClientCallbackPtr(std::move(callback), std::move(callbackContext));
  oneway_echoImpl(rpcOptions, std::move(ctx), std::move(wrappedCallback), req);
}

void EchoServiceAsyncClient::oneway_echoImpl(
    apache::thrift::RpcOptions& rpcOptions,
    std::shared_ptr<apache::thrift::detail::ac::ClientRequestContext> ctx,
    apache::thrift::RequestClientCallback::Ptr callback,
    const ::idl::thrift::cpp2::MockRequest& req) {
  switch (apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId()) {
    case apache::thrift::protocol::T_BINARY_PROTOCOL: {
      apache::thrift::BinaryProtocolWriter writer;
      oneway_echoT(&writer, rpcOptions, std::move(ctx), std::move(callback), req);
      break;
    }
    case apache::thrift::protocol::T_COMPACT_PROTOCOL: {
      apache::thrift::CompactProtocolWriter writer;
      oneway_echoT(&writer, rpcOptions, std::move(ctx), std::move(callback), req);
      break;
    }
    default: {
      apache::thrift::detail::ac::throw_app_exn("Could not find Protocol");
    }
  }
}

void EchoServiceAsyncClient::sync_oneway_echo(const ::idl::thrift::cpp2::MockRequest& req) {
  ::apache::thrift::RpcOptions rpcOptions;
  sync_oneway_echo(rpcOptions, req);
}

void EchoServiceAsyncClient::sync_oneway_echo(apache::thrift::RpcOptions& rpcOptions,
                                              const ::idl::thrift::cpp2::MockRequest& req) {
  apache::thrift::ClientReceiveState _returnState;
  apache::thrift::ClientSyncCallback<true> callback(&_returnState);
  auto protocolId = apache::thrift::GeneratedAsyncClient::getChannel()->getProtocolId();
  auto evb = apache::thrift::GeneratedAsyncClient::getChannel()->getEventBase();
  auto ctx = std::make_shared<apache::thrift::detail::ac::ClientRequestContext>(
      protocolId, rpcOptions.releaseWriteHeaders(), this->handlers_, this->getServiceName(),
      "EchoService.oneway_echo");
  auto wrappedCallback = apache::thrift::RequestClientCallback::Ptr(&callback);
  oneway_echoImpl(rpcOptions, ctx, std::move(wrappedCallback), req);
  callback.waitUntilDone(evb);
}

folly::Future<folly::Unit> EchoServiceAsyncClient::future_oneway_echo(
    const ::idl::thrift::cpp2::MockRequest& req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return future_oneway_echo(rpcOptions, req);
}

folly::SemiFuture<folly::Unit> EchoServiceAsyncClient::semifuture_oneway_echo(
    const ::idl::thrift::cpp2::MockRequest& req) {
  ::apache::thrift::RpcOptions rpcOptions;
  return semifuture_oneway_echo(rpcOptions, req);
}

folly::Future<folly::Unit> EchoServiceAsyncClient::future_oneway_echo(
    apache::thrift::RpcOptions& rpcOptions, const ::idl::thrift::cpp2::MockRequest& req) {
  folly::Promise<folly::Unit> _promise;
  auto _future = _promise.getFuture();
  auto callback =
      std::make_unique<apache::thrift::OneWayFutureCallback>(std::move(_promise), channel_);
  oneway_echo(rpcOptions, std::move(callback), req);
  return _future;
}

folly::SemiFuture<folly::Unit> EchoServiceAsyncClient::semifuture_oneway_echo(
    apache::thrift::RpcOptions& rpcOptions, const ::idl::thrift::cpp2::MockRequest& req) {
  auto callbackAndFuture = makeOneWaySemiFutureCallback(channel_);
  auto callback = std::move(callbackAndFuture.first);
  oneway_echo(rpcOptions, std::move(callback), req);
  return std::move(callbackAndFuture.second);
}

void EchoServiceAsyncClient::oneway_echo(
    folly::Function<void(::apache::thrift::ClientReceiveState&&)> callback,
    const ::idl::thrift::cpp2::MockRequest& req) {
  oneway_echo(std::make_unique<apache::thrift::FunctionReplyCallback>(std::move(callback)), req);
}

#if FOLLY_HAS_COROUTINES
#endif  // FOLLY_HAS_COROUTINES

}  // namespace cpp2
}  // namespace thrift
}  // namespace idl
